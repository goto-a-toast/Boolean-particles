<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Particles - Genuary</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000000;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #1a1a1a;
      letter-spacing: 0.2em;
      z-index: 10;
      text-shadow: 0 0 3px rgba(255,255,255,0.1);
    }
  </style>
</head>
<body>
  <div id="info">SPACE: pause | R: reset | 1-4: mode</div>
  <script>
// パーティクルシステム
let particles = [];
const NUM_PARTICLES = 800;
let time = 0;
let mode = 1;
let isPaused = false;

// イージング関数
function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function easeOutExpo(t) {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
}

function easeInQuart(t) {
  return t * t * t * t;
}

// ブール演算でパーティクルの状態を決定
function booleanState(x, y, t) {
  const ix = floor(x / 50);
  const iy = floor(y / 50);
  const it = floor(t / 60);
  
  switch(mode) {
    case 1: return (ix ^ iy ^ it) % 4;       // XOR - 複雑なパターン
    case 2: return (ix & iy & it) % 4;       // AND - 集中パターン
    case 3: return (ix | iy) ^ it % 4;       // OR + XOR - 波動パターン
    case 4: return ((ix ^ iy) & it) % 4;     // 混合 - リズミカル
    default: return (ix ^ iy) % 4;
  }
}

class Particle {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = random(width);
    this.y = random(height);
    this.homeX = this.x;
    this.homeY = this.y;
    this.size = random(1, 4);
    this.baseSpeed = random(0.5, 2);
    this.angle = random(TWO_PI);
    this.noiseOffset = random(1000);
    this.life = 1;
    this.maxLife = random(200, 500);
    this.age = 0;
    // ダークなモノクロ + 時々グリッチカラー
    const colorType = random(1);
    if (colorType < 0.85) {
      this.hue = 0; // モノクロ（グレー）
      this.isMonochrome = true;
    } else {
      // 稀にグリッチカラー（青、緑、赤）
      this.hue = random([180, 120, 0, 280]);
      this.isMonochrome = false;
    }
    this.trail = [];
    this.maxTrail = floor(random(5, 15));
    this.phase = random(TWO_PI);
    this.targetX = this.x;
    this.targetY = this.y;
    this.easeProgress = 0;
    this.easeType = floor(random(3));
    this.glitchOffset = { x: 0, y: 0 };
  }
  
  update() {
    this.age++;

    // ブール演算で状態を取得
    const state = booleanState(this.x, this.y, time);

    // 状態に応じた動きの緩急
    let speedMult = 1;
    let easedProgress;

    switch(state) {
      case 0: // 静止に近い、ゆっくり
        speedMult = 0.1;
        this.easeProgress += 0.005;
        easedProgress = easeInQuart(this.easeProgress % 1);
        break;
      case 1: // 中速、スムーズ
        speedMult = 0.5;
        this.easeProgress += 0.02;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        break;
      case 2: // 高速バースト
        speedMult = 2.5;
        this.easeProgress += 0.05;
        easedProgress = easeOutExpo(this.easeProgress % 1);
        break;
      case 3: // パルス的な動き
        speedMult = sin(time * 0.1 + this.phase) * 1.5 + 0.5;
        this.easeProgress += 0.03;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        break;
    }

    // グリッチエフェクト: ランダムにピクセルシフト
    if (random(1) < 0.02) {
      this.glitchOffset.x = random(-5, 5);
      this.glitchOffset.y = random(-5, 5);
    } else {
      this.glitchOffset.x *= 0.9;
      this.glitchOffset.y *= 0.9;
    }

    // ノイズベースの移動
    const noiseScale = 0.003;
    const noiseVal = noise(
      this.x * noiseScale + this.noiseOffset,
      this.y * noiseScale,
      time * 0.005
    );

    this.angle = noiseVal * TWO_PI * 4;

    // 新しいターゲット設定（イージングリセット時）
    if (this.easeProgress >= 1) {
      this.easeProgress = 0;
      this.targetX = this.x + cos(this.angle) * random(50, 150);
      this.targetY = this.y + sin(this.angle) * random(50, 150);
    }

    // 速度計算（緩急あり）
    const speed = this.baseSpeed * speedMult * easedProgress;

    // 位置更新
    this.x += cos(this.angle) * speed;
    this.y += sin(this.angle) * speed;

    // トレイル記録
    if (frameCount % 2 === 0) {
      this.trail.push({ x: this.x, y: this.y, alpha: 1 });
      if (this.trail.length > this.maxTrail) {
        this.trail.shift();
      }
    }

    // トレイルのフェード
    for (let t of this.trail) {
      t.alpha *= 0.95;
    }

    // ライフサイクル
    this.life = 1 - (this.age / this.maxLife);

    // 画面外またはライフ終了でリセット
    if (this.x < -50 || this.x > width + 50 ||
        this.y < -50 || this.y > height + 50 ||
        this.life <= 0) {
      this.reset();
    }
  }
  
  draw() {
    const state = booleanState(this.x, this.y, time);

    // ダークでモノクロ基調の色設定
    let hueShift = 0;
    let saturation = 0;
    let brightness = 20;

    if (this.isMonochrome) {
      // モノクロ: グレースケール、非常に暗い
      switch(state) {
        case 0:
          saturation = 0;
          brightness = 8;
          break;
        case 1:
          saturation = 0;
          brightness = 15;
          break;
        case 2:
          saturation = 5;
          brightness = 25;
          break;
        case 3:
          saturation = 0;
          brightness = 18;
          break;
      }
    } else {
      // グリッチカラー: 彩度低め、暗め
      switch(state) {
        case 0:
          saturation = 20;
          brightness = 12;
          break;
        case 1:
          saturation = 30;
          brightness = 20;
          break;
        case 2:
          saturation = 50;
          brightness = 35;
          break;
        case 3:
          saturation = 40;
          brightness = 25;
          break;
      }
    }

    // グリッチオフセット適用
    const drawX = this.x + this.glitchOffset.x;
    const drawY = this.y + this.glitchOffset.y;

    // トレイル描画（より暗く）
    noFill();
    for (let i = 0; i < this.trail.length - 1; i++) {
      const t = this.trail[i];
      const alpha = t.alpha * this.life * 0.15;
      stroke((this.hue + hueShift) % 360, saturation * 0.5, brightness * 0.4, alpha);
      strokeWeight(this.size * 0.3 * (i / this.trail.length));
      line(this.trail[i].x, this.trail[i].y,
           this.trail[i+1].x, this.trail[i+1].y);
    }

    // パーティクル本体
    noStroke();

    // 色収差エフェクト（グリッチカラーのみ、まれに）
    if (!this.isMonochrome && random(1) < 0.3) {
      // RGB分離
      fill(0, 0, brightness * 0.6, this.life * 0.15);
      ellipse(drawX - 1, drawY, this.size * 1.5, this.size * 1.5);

      fill(120, saturation * 0.7, brightness * 0.6, this.life * 0.15);
      ellipse(drawX + 1, drawY, this.size * 1.5, this.size * 1.5);
    }

    // グロー効果（非常に控えめ）
    const glowSize = this.size * (state === 2 ? 3 : 1.8);
    for (let i = 2; i > 0; i--) {
      fill((this.hue + hueShift) % 360, saturation, brightness * 0.6,
           this.life * 0.05 / i);
      ellipse(drawX, drawY, glowSize * i, glowSize * i);
    }

    // コア
    fill((this.hue + hueShift) % 360, saturation * 0.3, brightness * 1.2, this.life * 0.8);
    ellipse(drawX, drawY, this.size, this.size);
  }
}

// グリッドのビジュアル化（背景）
function drawBooleanGrid() {
  const gridSize = 50;

  for (let x = 0; x < width; x += gridSize) {
    for (let y = 0; y < height; y += gridSize) {
      const state = booleanState(x, y, time);

      // 極めて薄いグリッド表示（ほとんど見えない）
      noFill();
      stroke(0, 0, 10, 0.01 + state * 0.005);
      strokeWeight(0.3);
      rect(x, y, gridSize, gridSize);

      // 状態2のセルはわずかに明るく
      if (state === 2 && random(1) < 0.3) {
        fill(0, 0, 12, 0.02);
        noStroke();
        rect(x, y, gridSize, gridSize);
      }
    }
  }
}

// 接続線（近いパーティクル同士）
function drawConnections() {
  const maxDist = 80;

  stroke(0, 0, 15, 0.03);
  strokeWeight(0.3);

  for (let i = 0; i < particles.length; i += 10) {
    for (let j = i + 1; j < particles.length; j += 10) {
      const d = dist(particles[i].x, particles[i].y,
                     particles[j].x, particles[j].y);

      if (d < maxDist) {
        const state1 = booleanState(particles[i].x, particles[i].y, time);
        const state2 = booleanState(particles[j].x, particles[j].y, time);

        // XOR: 状態が異なる場合のみ接続
        if ((state1 ^ state2) !== 0) {
          const alpha = map(d, 0, maxDist, 0.06, 0);
          stroke(0, 0, 18, alpha);
          line(particles[i].x, particles[i].y,
               particles[j].x, particles[j].y);
        }
      }
    }
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // パーティクル初期化
  for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Particle());
  }
  
  noiseSeed(42);
}

function draw() {
  // 背景（フェード効果 - より暗く）
  noStroke();
  fill(0, 0, 0, 0.2);
  rect(0, 0, width, height);

  if (!isPaused) {
    time++;
  }

  // スキャンライン効果（ノイズ的）
  drawScanlines();

  // グレイン/ノイズ効果
  drawGrainNoise();

  // 背景グリッド
  drawBooleanGrid();

  // 接続線
  drawConnections();

  // パーティクル更新・描画
  for (let p of particles) {
    if (!isPaused) {
      p.update();
    }
    p.draw();
  }

  // グリッチエフェクト（全体）
  drawGlobalGlitch();

  // モード表示
  drawModeIndicator();
}

// スキャンライン効果
function drawScanlines() {
  stroke(0, 0, 15, 0.03);
  strokeWeight(1);

  for (let y = 0; y < height; y += 3) {
    if (random(1) < 0.7) {
      line(0, y, width, y);
    }
  }
}

// グレイン/ノイズ効果
function drawGrainNoise() {
  for (let i = 0; i < 50; i++) {
    const x = random(width);
    const y = random(height);
    const brightness = random(10, 25);

    noStroke();
    fill(0, 0, brightness, random(0.05, 0.15));
    ellipse(x, y, random(1, 3), random(1, 3));
  }
}

// グローバルグリッチエフェクト
function drawGlobalGlitch() {
  // まれに画面全体にグリッチ
  if (random(1) < 0.01) {
    const glitchHeight = random(5, 30);
    const glitchY = random(height);

    noStroke();
    // RGB色収差的なグリッチ
    fill(0, 0, 20, 0.3);
    rect(0, glitchY, width, glitchHeight);

    fill(120, 40, 30, 0.15);
    rect(0, glitchY + 2, width, glitchHeight);

    fill(280, 40, 30, 0.15);
    rect(0, glitchY - 2, width, glitchHeight);
  }
}

function drawModeIndicator() {
  const modeNames = ['', 'XOR', 'AND', 'OR^XOR', 'MIXED'];

  fill(0, 0, 25, 0.4);
  noStroke();
  textFont('Courier New');
  textSize(12);
  textAlign(LEFT, TOP);
  text(`MODE ${mode}: ${modeNames[mode]}`, 20, 20);
  text(`PARTICLES: ${NUM_PARTICLES}`, 20, 38);
  text(`TIME: ${time}`, 20, 56);
}

function keyPressed() {
  if (key === ' ') {
    isPaused = !isPaused;
  } else if (key === 'r' || key === 'R') {
    // リセット
    time = 0;
    for (let p of particles) {
      p.reset();
    }
  } else if (key >= '1' && key <= '4') {
    mode = int(key);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  // クリック位置にパーティクルバースト
  for (let i = 0; i < 50; i++) {
    if (particles.length > i) {
      particles[i].x = mouseX + random(-20, 20);
      particles[i].y = mouseY + random(-20, 20);
      particles[i].easeProgress = 0;
      particles[i].age = 0;
      particles[i].life = 1;
    }
  }
}
  </script>
</body>
</html>
