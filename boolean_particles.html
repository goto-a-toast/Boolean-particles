<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Particles - Genuary</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #050508;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #333;
      letter-spacing: 0.2em;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="info">SPACE: pause | R: reset | 1-4: mode</div>
  <script>
// パーティクルシステム
let particles = [];
const NUM_PARTICLES = 800;
let time = 0;
let mode = 1;
let isPaused = false;

// イージング関数
function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function easeOutExpo(t) {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
}

function easeInQuart(t) {
  return t * t * t * t;
}

// ブール演算でパーティクルの状態を決定
function booleanState(x, y, t) {
  const ix = floor(x / 50);
  const iy = floor(y / 50);
  const it = floor(t / 60);
  
  switch(mode) {
    case 1: return (ix ^ iy ^ it) % 4;       // XOR - 複雑なパターン
    case 2: return (ix & iy & it) % 4;       // AND - 集中パターン
    case 3: return (ix | iy) ^ it % 4;       // OR + XOR - 波動パターン
    case 4: return ((ix ^ iy) & it) % 4;     // 混合 - リズミカル
    default: return (ix ^ iy) % 4;
  }
}

class Particle {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = random(width);
    this.y = random(height);
    this.homeX = this.x;
    this.homeY = this.y;
    this.size = random(1, 4);
    this.baseSpeed = random(0.5, 2);
    this.angle = random(TWO_PI);
    this.noiseOffset = random(1000);
    this.life = 1;
    this.maxLife = random(200, 500);
    this.age = 0;
    this.hue = random(200, 280); // 青〜紫のダーク系
    this.trail = [];
    this.maxTrail = floor(random(5, 15));
    this.phase = random(TWO_PI);
    this.targetX = this.x;
    this.targetY = this.y;
    this.easeProgress = 0;
    this.easeType = floor(random(3));
  }
  
  update() {
    this.age++;
    
    // ブール演算で状態を取得
    const state = booleanState(this.x, this.y, time);
    
    // 状態に応じた動きの緩急
    let speedMult = 1;
    let easedProgress;
    
    switch(state) {
      case 0: // 静止に近い、ゆっくり
        speedMult = 0.1;
        this.easeProgress += 0.005;
        easedProgress = easeInQuart(this.easeProgress % 1);
        break;
      case 1: // 中速、スムーズ
        speedMult = 0.5;
        this.easeProgress += 0.02;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        break;
      case 2: // 高速バースト
        speedMult = 2.5;
        this.easeProgress += 0.05;
        easedProgress = easeOutExpo(this.easeProgress % 1);
        break;
      case 3: // パルス的な動き
        speedMult = sin(time * 0.1 + this.phase) * 1.5 + 0.5;
        this.easeProgress += 0.03;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        break;
    }
    
    // ノイズベースの移動
    const noiseScale = 0.003;
    const noiseVal = noise(
      this.x * noiseScale + this.noiseOffset,
      this.y * noiseScale,
      time * 0.005
    );
    
    this.angle = noiseVal * TWO_PI * 4;
    
    // 新しいターゲット設定（イージングリセット時）
    if (this.easeProgress >= 1) {
      this.easeProgress = 0;
      this.targetX = this.x + cos(this.angle) * random(50, 150);
      this.targetY = this.y + sin(this.angle) * random(50, 150);
    }
    
    // 速度計算（緩急あり）
    const speed = this.baseSpeed * speedMult * easedProgress;
    
    // 位置更新
    this.x += cos(this.angle) * speed;
    this.y += sin(this.angle) * speed;
    
    // トレイル記録
    if (frameCount % 2 === 0) {
      this.trail.push({ x: this.x, y: this.y, alpha: 1 });
      if (this.trail.length > this.maxTrail) {
        this.trail.shift();
      }
    }
    
    // トレイルのフェード
    for (let t of this.trail) {
      t.alpha *= 0.95;
    }
    
    // ライフサイクル
    this.life = 1 - (this.age / this.maxLife);
    
    // 画面外またはライフ終了でリセット
    if (this.x < -50 || this.x > width + 50 || 
        this.y < -50 || this.y > height + 50 ||
        this.life <= 0) {
      this.reset();
    }
  }
  
  draw() {
    const state = booleanState(this.x, this.y, time);
    
    // 状態に応じた色相シフト
    let hueShift = 0;
    let saturation = 60;
    let brightness = 80;
    
    switch(state) {
      case 0:
        hueShift = 0;
        saturation = 40;
        brightness = 30;
        break;
      case 1:
        hueShift = 20;
        saturation = 50;
        brightness = 50;
        break;
      case 2:
        hueShift = 40;
        saturation = 80;
        brightness = 100;
        break;
      case 3:
        hueShift = -20;
        saturation = 70;
        brightness = 70;
        break;
    }
    
    // トレイル描画
    noFill();
    for (let i = 0; i < this.trail.length - 1; i++) {
      const t = this.trail[i];
      const alpha = t.alpha * this.life * 0.3;
      stroke((this.hue + hueShift) % 360, saturation, brightness * 0.5, alpha);
      strokeWeight(this.size * 0.5 * (i / this.trail.length));
      line(this.trail[i].x, this.trail[i].y, 
           this.trail[i+1].x, this.trail[i+1].y);
    }
    
    // パーティクル本体
    noStroke();
    
    // グロー効果
    const glowSize = this.size * (state === 2 ? 4 : 2);
    for (let i = 3; i > 0; i--) {
      fill((this.hue + hueShift) % 360, saturation, brightness, 
           this.life * 0.1 / i);
      ellipse(this.x, this.y, glowSize * i, glowSize * i);
    }
    
    // コア
    fill((this.hue + hueShift) % 360, saturation * 0.5, 100, this.life);
    ellipse(this.x, this.y, this.size, this.size);
  }
}

// グリッドのビジュアル化（背景）
function drawBooleanGrid() {
  const gridSize = 50;
  
  for (let x = 0; x < width; x += gridSize) {
    for (let y = 0; y < height; y += gridSize) {
      const state = booleanState(x, y, time);
      
      // 非常に薄いグリッド表示
      noFill();
      stroke(240, 50, 20, 0.05 + state * 0.02);
      strokeWeight(0.5);
      rect(x, y, gridSize, gridSize);
      
      // 状態2のセルは少し明るく
      if (state === 2) {
        fill(260, 60, 30, 0.05);
        noStroke();
        rect(x, y, gridSize, gridSize);
      }
    }
  }
}

// 接続線（近いパーティクル同士）
function drawConnections() {
  const maxDist = 80;
  
  stroke(250, 40, 60, 0.1);
  strokeWeight(0.5);
  
  for (let i = 0; i < particles.length; i += 10) {
    for (let j = i + 1; j < particles.length; j += 10) {
      const d = dist(particles[i].x, particles[i].y,
                     particles[j].x, particles[j].y);
      
      if (d < maxDist) {
        const state1 = booleanState(particles[i].x, particles[i].y, time);
        const state2 = booleanState(particles[j].x, particles[j].y, time);
        
        // XOR: 状態が異なる場合のみ接続
        if ((state1 ^ state2) !== 0) {
          const alpha = map(d, 0, maxDist, 0.15, 0);
          stroke(260, 50, 70, alpha);
          line(particles[i].x, particles[i].y,
               particles[j].x, particles[j].y);
        }
      }
    }
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // パーティクル初期化
  for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Particle());
  }
  
  noiseSeed(42);
}

function draw() {
  // 背景（フェード効果）
  noStroke();
  fill(250, 30, 5, 0.15);
  rect(0, 0, width, height);
  
  if (!isPaused) {
    time++;
  }
  
  // 背景グリッド
  drawBooleanGrid();
  
  // 接続線
  drawConnections();
  
  // パーティクル更新・描画
  for (let p of particles) {
    if (!isPaused) {
      p.update();
    }
    p.draw();
  }
  
  // モード表示
  drawModeIndicator();
}

function drawModeIndicator() {
  const modeNames = ['', 'XOR', 'AND', 'OR^XOR', 'MIXED'];
  
  fill(0, 0, 100, 0.3);
  noStroke();
  textFont('Courier New');
  textSize(12);
  textAlign(LEFT, TOP);
  text(`MODE ${mode}: ${modeNames[mode]}`, 20, 20);
  text(`PARTICLES: ${NUM_PARTICLES}`, 20, 38);
  text(`TIME: ${time}`, 20, 56);
}

function keyPressed() {
  if (key === ' ') {
    isPaused = !isPaused;
  } else if (key === 'r' || key === 'R') {
    // リセット
    time = 0;
    for (let p of particles) {
      p.reset();
    }
  } else if (key >= '1' && key <= '4') {
    mode = int(key);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  // クリック位置にパーティクルバースト
  for (let i = 0; i < 50; i++) {
    if (particles.length > i) {
      particles[i].x = mouseX + random(-20, 20);
      particles[i].y = mouseY + random(-20, 20);
      particles[i].easeProgress = 0;
      particles[i].age = 0;
      particles[i].life = 1;
    }
  }
}
  </script>
</body>
</html>
