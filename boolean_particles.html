<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boolean Particles - Genuary</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #050508;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #666;
      letter-spacing: 0.2em;
      z-index: 10;
      background: rgba(0, 0, 0, 0.3);
      padding: 8px 16px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="info">SPACE: pause | R: reset | 1-4: mode | CLICK: spawn particles</div>
  <script>
// パーティクルシステム
let particles = [];
const NUM_PARTICLES = 800;
let time = 0;
let mode = 1;
let isPaused = false;

// イージング関数
function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function easeOutExpo(t) {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
}

function easeInQuart(t) {
  return t * t * t * t;
}

// ブール演算でパーティクルの状態を決定
function booleanState(x, y, t) {
  const ix = floor(x / 50);
  const iy = floor(y / 50);
  const it = floor(t / 60);
  
  switch(mode) {
    case 1: return (ix ^ iy ^ it) % 4;       // XOR - 複雑なパターン
    case 2: return (ix & iy & it) % 4;       // AND - 集中パターン
    case 3: return (ix | iy) ^ it % 4;       // OR + XOR - 波動パターン
    case 4: return ((ix ^ iy) & it) % 4;     // 混合 - リズミカル
    default: return (ix ^ iy) % 4;
  }
}

class Particle {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = random(width);
    this.y = random(height);
    this.homeX = this.x;
    this.homeY = this.y;
    this.size = random(1, 4);
    this.baseSpeed = random(0.5, 2);
    this.angle = random(TWO_PI);
    this.noiseOffset = random(1000);
    this.life = 1;
    this.maxLife = random(200, 500);
    this.age = 0;
    this.hue = random(200, 280); // 青〜紫のダーク系
    this.trail = [];
    this.maxTrail = floor(random(12, 25)); // より長いトレイルで動きを明確に
    this.phase = random(TWO_PI);
    this.targetX = this.x;
    this.targetY = this.y;
    this.easeProgress = 0;
    this.easeType = floor(random(3));
  }
  
  update() {
    this.age++;

    // ブール演算で状態を取得
    const state = booleanState(this.x, this.y, time);

    // 状態に応じた動きの緩急と方向性
    let speedMult = 1;
    let easedProgress;
    let moveX = 0;
    let moveY = 0;

    switch(state) {
      case 0: // 円運動 - ゆっくり回転
        speedMult = 0.8;
        this.easeProgress += 0.015;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        // 円運動のパラメータ
        const radius = 30;
        const circleAngle = time * 0.02 + this.phase;
        moveX = cos(circleAngle) * radius * 0.1;
        moveY = sin(circleAngle) * radius * 0.1;
        this.angle = circleAngle; // 視覚的な方向を保存
        break;

      case 1: // 直線運動 - スムーズに前進
        speedMult = 1.2;
        this.easeProgress += 0.025;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        // ノイズベースの方向決定（滑らか）
        const noiseScale1 = 0.003;
        const noiseVal1 = noise(
          this.x * noiseScale1 + this.noiseOffset,
          this.y * noiseScale1,
          time * 0.003
        );
        this.angle = noiseVal1 * TWO_PI * 2;
        moveX = cos(this.angle) * speedMult * easedProgress;
        moveY = sin(this.angle) * speedMult * easedProgress;
        break;

      case 2: // 高速直進 - 明確な方向へ
        speedMult = 3.0;
        this.easeProgress += 0.08;
        easedProgress = easeOutExpo(this.easeProgress % 1);
        // より強い方向性
        const noiseScale2 = 0.005;
        const noiseVal2 = noise(
          this.x * noiseScale2 + this.noiseOffset,
          this.y * noiseScale2,
          time * 0.01
        );
        this.angle = noiseVal2 * TWO_PI;
        moveX = cos(this.angle) * speedMult * easedProgress;
        moveY = sin(this.angle) * speedMult * easedProgress;
        break;

      case 3: // 波形運動 - 上下に揺れながら進む
        speedMult = 1.5;
        this.easeProgress += 0.04;
        easedProgress = easeInOutCubic(this.easeProgress % 1);
        // 基本方向
        const noiseScale3 = 0.004;
        const noiseVal3 = noise(
          this.x * noiseScale3 + this.noiseOffset,
          this.y * noiseScale3,
          time * 0.005
        );
        const baseAngle = noiseVal3 * TWO_PI;
        // 波形の振動を加える
        const waveOffset = sin(time * 0.08 + this.phase) * PI / 3;
        this.angle = baseAngle + waveOffset;
        moveX = cos(this.angle) * speedMult * easedProgress;
        moveY = sin(this.angle) * speedMult * easedProgress;
        break;
    }

    // 位置更新
    this.x += moveX;
    this.y += moveY;
    
    // トレイル記録
    if (frameCount % 2 === 0) {
      this.trail.push({ x: this.x, y: this.y, alpha: 1 });
      if (this.trail.length > this.maxTrail) {
        this.trail.shift();
      }
    }
    
    // トレイルのフェード
    for (let t of this.trail) {
      t.alpha *= 0.95;
    }
    
    // ライフサイクル
    this.life = 1 - (this.age / this.maxLife);
    
    // 画面外またはライフ終了でリセット
    if (this.x < -50 || this.x > width + 50 || 
        this.y < -50 || this.y > height + 50 ||
        this.life <= 0) {
      this.reset();
    }
  }
  
  draw() {
    const state = booleanState(this.x, this.y, time);

    // 状態に応じた色・サイズ・明るさ（よりわかりやすく）
    let hueShift = 0;
    let saturation = 60;
    let brightness = 80;
    let sizeMultiplier = 1;

    switch(state) {
      case 0: // 円運動 - 青紫、中サイズ
        hueShift = 0;
        saturation = 70;
        brightness = 50;
        sizeMultiplier = 1.2;
        break;
      case 1: // 直線運動 - 緑青、標準サイズ
        hueShift = 60;
        saturation = 80;
        brightness = 70;
        sizeMultiplier = 1.0;
        break;
      case 2: // 高速直進 - 鮮やかなピンク、大きめ
        hueShift = 320;
        saturation = 90;
        brightness = 100;
        sizeMultiplier = 1.8;
        break;
      case 3: // 波形運動 - 黄色、やや大きめ
        hueShift = 45;
        saturation = 85;
        brightness = 85;
        sizeMultiplier = 1.4;
        break;
    }

    // 強化されたトレイル描画（動きの方向を明確に）
    noFill();
    for (let i = 0; i < this.trail.length - 1; i++) {
      const t = this.trail[i];
      const alpha = t.alpha * this.life * 0.5; // より濃く
      const trailHue = (this.hue + hueShift) % 360;
      stroke(trailHue, saturation * 0.8, brightness * 0.7, alpha);
      strokeWeight(this.size * sizeMultiplier * 0.8 * (i / this.trail.length));
      line(this.trail[i].x, this.trail[i].y,
           this.trail[i+1].x, this.trail[i+1].y);
    }

    // 方向矢印（移動方向を視覚的に表示）
    if (this.trail.length >= 2) {
      const lastPoint = this.trail[this.trail.length - 1];
      const arrowLength = 12 * sizeMultiplier;
      const arrowAngle = this.angle;
      const arrowX = this.x + cos(arrowAngle) * arrowLength;
      const arrowY = this.y + sin(arrowAngle) * arrowLength;

      stroke((this.hue + hueShift) % 360, saturation, brightness, this.life * 0.6);
      strokeWeight(1.5 * sizeMultiplier);
      line(this.x, this.y, arrowX, arrowY);

      // 矢印の先端
      const arrowHeadLength = 5 * sizeMultiplier;
      const arrowHeadAngle = PI / 6;
      stroke((this.hue + hueShift) % 360, saturation, brightness, this.life * 0.8);
      line(arrowX, arrowY,
           arrowX - cos(arrowAngle - arrowHeadAngle) * arrowHeadLength,
           arrowY - sin(arrowAngle - arrowHeadAngle) * arrowHeadLength);
      line(arrowX, arrowY,
           arrowX - cos(arrowAngle + arrowHeadAngle) * arrowHeadLength,
           arrowY - sin(arrowAngle + arrowHeadAngle) * arrowHeadLength);
    }

    // パーティクル本体
    noStroke();

    // グロー効果
    const glowSize = this.size * sizeMultiplier * (state === 2 ? 5 : 3);
    for (let i = 3; i > 0; i--) {
      fill((this.hue + hueShift) % 360, saturation, brightness,
           this.life * 0.15 / i);
      ellipse(this.x, this.y, glowSize * i, glowSize * i);
    }

    // コア（より明るく鮮明に）
    fill((this.hue + hueShift) % 360, saturation * 0.6, 100, this.life);
    ellipse(this.x, this.y, this.size * sizeMultiplier, this.size * sizeMultiplier);
  }
}

// グリッドのビジュアル化（背景）- より明確に
function drawBooleanGrid() {
  const gridSize = 50;

  for (let x = 0; x < width; x += gridSize) {
    for (let y = 0; y < height; y += gridSize) {
      const state = booleanState(x, y, time);

      // 状態に応じた背景色（よりわかりやすく）
      let gridHue, gridSat, gridBright, gridAlpha;

      switch(state) {
        case 0: // 円運動エリア - 青紫
          gridHue = 260;
          gridSat = 60;
          gridBright = 20;
          gridAlpha = 0.15;
          break;
        case 1: // 直線運動エリア - 緑青
          gridHue = 180;
          gridSat = 50;
          gridBright = 25;
          gridAlpha = 0.12;
          break;
        case 2: // 高速エリア - ピンク
          gridHue = 320;
          gridSat = 70;
          gridBright = 35;
          gridAlpha = 0.25;
          break;
        case 3: // 波形エリア - 黄色
          gridHue = 45;
          gridSat = 60;
          gridBright = 30;
          gridAlpha = 0.18;
          break;
      }

      // セルの塗りつぶし
      fill(gridHue, gridSat, gridBright, gridAlpha);
      noStroke();
      rect(x, y, gridSize, gridSize);

      // グリッド線（より明確に）
      noFill();
      stroke(gridHue, gridSat, gridBright + 20, 0.3);
      strokeWeight(1);
      rect(x, y, gridSize, gridSize);

      // 状態インジケーター（中央に小さい図形）
      push();
      translate(x + gridSize / 2, y + gridSize / 2);
      fill(gridHue, gridSat + 20, gridBright + 40, 0.4);
      noStroke();

      switch(state) {
        case 0: // 円
          ellipse(0, 0, 8, 8);
          break;
        case 1: // 矢印
          triangle(-4, 0, 4, 0, 0, -6);
          break;
        case 2: // 星形
          beginShape();
          for (let i = 0; i < 5; i++) {
            const angle = (i * TWO_PI / 5) - PI / 2;
            vertex(cos(angle) * 5, sin(angle) * 5);
            const innerAngle = (i * TWO_PI / 5) + PI / 5 - PI / 2;
            vertex(cos(innerAngle) * 2.5, sin(innerAngle) * 2.5);
          }
          endShape(CLOSE);
          break;
        case 3: // 波線
          noFill();
          stroke(gridHue, gridSat + 20, gridBright + 40, 0.5);
          strokeWeight(1.5);
          beginShape();
          for (let i = -6; i <= 6; i += 2) {
            curveVertex(i, sin(i * 0.5) * 3);
          }
          endShape();
          break;
      }
      pop();
    }
  }
}

// 接続線（近いパーティクル同士）
function drawConnections() {
  const maxDist = 80;
  
  stroke(250, 40, 60, 0.1);
  strokeWeight(0.5);
  
  for (let i = 0; i < particles.length; i += 10) {
    for (let j = i + 1; j < particles.length; j += 10) {
      const d = dist(particles[i].x, particles[i].y,
                     particles[j].x, particles[j].y);
      
      if (d < maxDist) {
        const state1 = booleanState(particles[i].x, particles[i].y, time);
        const state2 = booleanState(particles[j].x, particles[j].y, time);
        
        // XOR: 状態が異なる場合のみ接続
        if ((state1 ^ state2) !== 0) {
          const alpha = map(d, 0, maxDist, 0.15, 0);
          stroke(260, 50, 70, alpha);
          line(particles[i].x, particles[i].y,
               particles[j].x, particles[j].y);
        }
      }
    }
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  
  // パーティクル初期化
  for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Particle());
  }
  
  noiseSeed(42);
}

function draw() {
  // 背景（フェード効果 - より濃く）
  noStroke();
  fill(250, 30, 5, 0.25);
  rect(0, 0, width, height);
  
  if (!isPaused) {
    time++;
  }
  
  // 背景グリッド
  drawBooleanGrid();
  
  // 接続線
  drawConnections();
  
  // パーティクル更新・描画
  for (let p of particles) {
    if (!isPaused) {
      p.update();
    }
    p.draw();
  }
  
  // モード表示
  drawModeIndicator();
}

function drawModeIndicator() {
  const modeNames = ['', 'XOR', 'AND', 'OR^XOR', 'MIXED'];

  fill(0, 0, 100, 0.5);
  noStroke();
  textFont('Courier New');
  textSize(12);
  textAlign(LEFT, TOP);
  text(`MODE ${mode}: ${modeNames[mode]}`, 20, 20);
  text(`PARTICLES: ${NUM_PARTICLES}`, 20, 38);
  text(`TIME: ${time}`, 20, 56);

  // 状態の凡例
  textSize(11);
  fill(0, 0, 100, 0.4);
  text('STATES:', 20, 80);

  const legendY = 100;
  const legendSpacing = 22;

  // State 0 - 円運動
  fill(260, 70, 50, 0.8);
  ellipse(30, legendY, 8, 8);
  fill(0, 0, 100, 0.4);
  text('State 0: Circular', 45, legendY - 5);

  // State 1 - 直線運動
  fill(180, 80, 70, 0.8);
  triangle(26, legendY + legendSpacing, 34, legendY + legendSpacing, 30, legendY + legendSpacing - 6);
  fill(0, 0, 100, 0.4);
  text('State 1: Linear', 45, legendY + legendSpacing - 5);

  // State 2 - 高速
  fill(320, 90, 100, 0.8);
  push();
  translate(30, legendY + legendSpacing * 2);
  beginShape();
  for (let i = 0; i < 5; i++) {
    const angle = (i * TWO_PI / 5) - PI / 2;
    vertex(cos(angle) * 4, sin(angle) * 4);
    const innerAngle = (i * TWO_PI / 5) + PI / 5 - PI / 2;
    vertex(cos(innerAngle) * 2, sin(innerAngle) * 2);
  }
  endShape(CLOSE);
  pop();
  fill(0, 0, 100, 0.4);
  text('State 2: Fast', 45, legendY + legendSpacing * 2 - 5);

  // State 3 - 波形
  noFill();
  stroke(45, 85, 85, 0.8);
  strokeWeight(1.5);
  beginShape();
  for (let i = -4; i <= 4; i += 1) {
    curveVertex(26 + i, legendY + legendSpacing * 3 + sin(i * 0.8) * 2);
  }
  endShape();
  noStroke();
  fill(0, 0, 100, 0.4);
  text('State 3: Wave', 45, legendY + legendSpacing * 3 - 5);
}

function keyPressed() {
  if (key === ' ') {
    isPaused = !isPaused;
  } else if (key === 'r' || key === 'R') {
    // リセット
    time = 0;
    for (let p of particles) {
      p.reset();
    }
  } else if (key >= '1' && key <= '4') {
    mode = int(key);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
  // クリック位置にパーティクルバースト
  for (let i = 0; i < 50; i++) {
    if (particles.length > i) {
      particles[i].x = mouseX + random(-20, 20);
      particles[i].y = mouseY + random(-20, 20);
      particles[i].easeProgress = 0;
      particles[i].age = 0;
      particles[i].life = 1;
    }
  }
}
  </script>
</body>
</html>
